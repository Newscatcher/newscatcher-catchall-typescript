// This file was auto-generated by Fern from our API Definition.

import * as CatchAllApi from "../../src/api/index";
import { CatchAllApiClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("MonitorsClient", () => {
    test("createMonitor (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reference_job_id: "reference_job_id", schedule: "every day at 12 PM UTC" };
        const rawResponseBody = { monitor_id: "monitor_id", status: "Monitor Created Successfully" };
        server
            .mockEndpoint()
            .post("/catchAll/monitors/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.monitors.createMonitor({
            reference_job_id: "reference_job_id",
            schedule: "every day at 12 PM UTC",
        });
        expect(response).toEqual({
            monitor_id: "monitor_id",
            status: "Monitor Created Successfully",
        });
    });

    test("createMonitor (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reference_job_id: "reference_job_id", schedule: "schedule" };
        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.createMonitor({
                reference_job_id: "reference_job_id",
                schedule: "schedule",
            });
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });

    test("listMonitorJobs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            monitor_id: "monitor_id",
            sort_order: "asc",
            total_jobs: 1,
            jobs: [{ job_id: "job_id", start_date: "2025-11-14T21:00:00Z", end_date: "2025-11-15T00:00:00Z" }],
        };
        server
            .mockEndpoint()
            .get("/catchAll/monitors/monitor_id/jobs")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.monitors.listMonitorJobs({
            monitor_id: "monitor_id",
        });
        expect(response).toEqual({
            monitor_id: "monitor_id",
            sort_order: "asc",
            total_jobs: 1,
            jobs: [
                {
                    job_id: "job_id",
                    start_date: "2025-11-14T21:00:00Z",
                    end_date: "2025-11-15T00:00:00Z",
                },
            ],
        });
    });

    test("listMonitorJobs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/catchAll/monitors/monitor_id/jobs")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.listMonitorJobs({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.NotFoundError);
    });

    test("listMonitorJobs (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/catchAll/monitors/monitor_id/jobs")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.listMonitorJobs({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });

    test("pullMonitorResults (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            monitor_id: "7f3a8b2c-1e4d-4a5b-9c8d-6e7f8a9b0c1d",
            cron_expression: "0 12 * * *",
            timezone: "UTC",
            reference_job: {
                query: "AI company acquisitions",
                context: "Focus on deal size and acquiring company details",
            },
            run_info: { first_run: "2025-10-23T12:00:00Z", last_run: "2025-11-07T12:00:00Z" },
            records: 487,
            status: "Done",
            all_records: [
                {
                    record_id: "5262823697790152939",
                    record_title: "Oracle Q1 2026 Earnings Exceed Expectations",
                    enrichment: {
                        record_title: "Oracle Q1 2026 Earnings Exceed Expectations",
                        company_name: "Oracle",
                        quarter_identifier: "Q1 2026",
                        revenue: "$14.9 billion",
                        revenue_change: "up 12%",
                        profit_margin: "42% non-GAAP operating margin",
                    },
                    citations: [
                        {
                            id: "8760624448e9815f9fb4abd114c75e76",
                            title: "Oracle Reports Strong Q1 2026 Results",
                            link: "https://example.com/article",
                            published_date: "2025-09-26T08:54:20Z",
                            job_id: "6269aa54-c332-4fff-8a65-0d4e82a365e8",
                            added_on: "2025-11-14T21:00:00Z",
                        },
                    ],
                    added_on: "2025-11-14T21:00:00Z",
                    updated_on: "2025-11-14T21:00:00Z",
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/catchAll/monitors/pull/monitor_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.monitors.pullMonitorResults({
            monitor_id: "monitor_id",
        });
        expect(response).toEqual({
            monitor_id: "7f3a8b2c-1e4d-4a5b-9c8d-6e7f8a9b0c1d",
            cron_expression: "0 12 * * *",
            timezone: "UTC",
            reference_job: {
                query: "AI company acquisitions",
                context: "Focus on deal size and acquiring company details",
            },
            run_info: {
                first_run: "2025-10-23T12:00:00Z",
                last_run: "2025-11-07T12:00:00Z",
            },
            records: 487,
            status: "Done",
            all_records: [
                {
                    record_id: "5262823697790152939",
                    record_title: "Oracle Q1 2026 Earnings Exceed Expectations",
                    enrichment: {
                        record_title: "Oracle Q1 2026 Earnings Exceed Expectations",
                        company_name: "Oracle",
                        quarter_identifier: "Q1 2026",
                        revenue: "$14.9 billion",
                        revenue_change: "up 12%",
                        profit_margin: "42% non-GAAP operating margin",
                    },
                    citations: [
                        {
                            id: "8760624448e9815f9fb4abd114c75e76",
                            title: "Oracle Reports Strong Q1 2026 Results",
                            link: "https://example.com/article",
                            published_date: "2025-09-26T08:54:20Z",
                            job_id: "6269aa54-c332-4fff-8a65-0d4e82a365e8",
                            added_on: "2025-11-14T21:00:00Z",
                        },
                    ],
                    added_on: "2025-11-14T21:00:00Z",
                    updated_on: "2025-11-14T21:00:00Z",
                },
            ],
        });
    });

    test("pullMonitorResults (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/catchAll/monitors/pull/monitor_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.pullMonitorResults({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.NotFoundError);
    });

    test("pullMonitorResults (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .get("/catchAll/monitors/pull/monitor_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.pullMonitorResults({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });

    test("disableMonitor (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true, message: "Monitor disabled successfully.", monitor_id: "monitor_id" };
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/disable")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.monitors.disableMonitor({
            monitor_id: "monitor_id",
        });
        expect(response).toEqual({
            success: true,
            message: "Monitor disabled successfully.",
            monitor_id: "monitor_id",
        });
    });

    test("disableMonitor (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/disable")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.disableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.ForbiddenError);
    });

    test("disableMonitor (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/disable")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.disableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.NotFoundError);
    });

    test("disableMonitor (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/disable")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.disableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });

    test("enableMonitor (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true, message: "Monitor enabled successfully.", monitor_id: "monitor_id" };
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/enable")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.monitors.enableMonitor({
            monitor_id: "monitor_id",
        });
        expect(response).toEqual({
            success: true,
            message: "Monitor enabled successfully.",
            monitor_id: "monitor_id",
        });
    });

    test("enableMonitor (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/enable")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.enableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.ForbiddenError);
    });

    test("enableMonitor (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/enable")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.enableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.NotFoundError);
    });

    test("enableMonitor (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server
            .mockEndpoint()
            .post("/catchAll/monitors/monitor_id/enable")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.monitors.enableMonitor({
                monitor_id: "monitor_id",
            });
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });

    test("listMonitors (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            total_monitors: 3,
            monitors: [
                {
                    monitor_id: "7f3a8b2c-1e4d-4a5b-9c8d-6e7f8a9b0c1d",
                    reference_job_id: "af7a26d6-cf0b-458c-a6ed-4b6318c74da3",
                    reference_job_query: "AI company acquisitions",
                    enabled: true,
                    schedule: "0 12 * * *",
                    schedule_human_readable: "Every 24 hours",
                    timezone: "UTC",
                    created_at: "2025-10-23T14:30:00Z",
                    webhook: { url: "url" },
                },
            ],
        };
        server.mockEndpoint().get("/catchAll/monitors").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.monitors.listMonitors();
        expect(response).toEqual({
            total_monitors: 3,
            monitors: [
                {
                    monitor_id: "7f3a8b2c-1e4d-4a5b-9c8d-6e7f8a9b0c1d",
                    reference_job_id: "af7a26d6-cf0b-458c-a6ed-4b6318c74da3",
                    reference_job_query: "AI company acquisitions",
                    enabled: true,
                    schedule: "0 12 * * *",
                    schedule_human_readable: "Every 24 hours",
                    timezone: "UTC",
                    created_at: "2025-10-23T14:30:00Z",
                    webhook: {
                        url: "url",
                    },
                },
            ],
        });
    });

    test("listMonitors (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/catchAll/monitors").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.monitors.listMonitors();
        }).rejects.toThrow(CatchAllApi.ForbiddenError);
    });

    test("listMonitors (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new CatchAllApiClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {};
        server.mockEndpoint().get("/catchAll/monitors").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.monitors.listMonitors();
        }).rejects.toThrow(CatchAllApi.UnprocessableEntityError);
    });
});
